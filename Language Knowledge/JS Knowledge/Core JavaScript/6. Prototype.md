
자바스크립트는 함수를 생성할 때 prototype 객체를 property에 넣어 두고 해당 함수가 new 연산자와 함께 생성자 함수로 활용될 경우 해당 instance에 `__proto__` 라는 property를 생성하고 prototype 객체를 참조하게 한다.

## <mark style="background: #FF5582A6;">개념</mark>
![[Pasted image 20240405013047.png]]
```js
var instance = new Constructor();
```

Prototype은 다음과 같이 움직인다.
1. `constructor` > `new` > `instance`

constructor에 new를 넣음으로써 instance가 생성된다.

2. `prototype` > `instance.__proto__`

instance가 생성됨과 동시에 `__proto__`라는 property도 생기게 되는데 이 property는 Constructor의 prototype을 참조한다.

## <mark style="background: #FFB86CA6;">prototype 객체</mark>

`__proto__`가 참조하는 prototype은 instance가 사용할 method를 저장한다.

고로 `__proto__`는 저장된 method들을 prototype을 거쳐서 사용할 수 있게 된다.

(공식적으로는 `__proto__` 가 아니라 Object.getPrototypeof(), Object.create()을 이용해서 `__proto__`을 사용한다.)

```js
var Person =  function (name){
	this._name = name;
}
Person.prototype.getName = function(){
	return this._name;
}

var suzi = new Person('Suzi');
suzi.__proto__.getName();
// undefined (예상과 다름)

suzi.__proto__ === Person.prototype //true
```

이때 `suzi.__proto__getName()`이 undefined가 나왔다는 건 함수는 있는데 리턴 값이 없다는 것이다.

이유는 위 코드에서 getName이 this.name을 리턴하는데 `suzi.__proto__.getName()`을 하게 되면 this가 `suzi.__proto__`를 지칭하게 되기 때문이다. (method로 사용되는 함수의 this는 호출한 객체를 가리킨다.)

`suzi.__proto__`에는 name이라는 프로퍼티가 없으니 객체에서 존재하지 않는 프로퍼티를 탐색하면 JS엔진에서 주는 `undefined` 가 나온 것이다.

```js
var suzi = new Person('Suzi');
suzi.__proto__._name='SUZI__proto__';
suzi.__proto__.getName(); // 'SUZI__proto__'
```

위 코드처럼 프로퍼티를 채우면 그대로 출력되게 된다.

## <mark style="background: #FFB86CA6;">생략할 수 있는 `__proto__`</mark>

`__proto__`는 생략하고 prototype 객체 안의 메소드를 사용할 수 있다.

```js
var suzi = new Person('Suzi',28);
suzi.getName(); // Suzi
var iu = new Person('Jieun',26);
iu.getName(); // Jieun
```

`__proto__`를 생략하게 되면 prototype은 instance에서 참조하게 되며 `__proto__`가 빠졌기 때문에 자연스럽게 

`this` 는 `instance` 를 가리키게 된다. (method를 호출한 객체가 instance가 되버리기 때문이다.)
![[Pasted image 20240405020240.png]]
## <mark style="background: #FFF3A3A6;">ex) 내가 만든 생성자 함수</mark>

```js
var a = function (animalName){
  this.animalName = animalName;
};
a.prototype.method1 = function(){};
a.prototype.property1 = 'PPAP';

var b = new a('dog');
console.dir(a);
console.dir(b);
```

![[Pasted image 20240405022930.png]]

실제로 코드를 만들어서 찍어보면 a 함수는 애초에 `prototype` 이라는 걸 갖고 있고

a의 instance인 b의 `__proto__` (공식적으로는 `[[Prototype]]`) 에 해당 `prototype`객체가 저장되어 있다. (여기서는 `a`로 써져 있는데 일부 인스턴스는 자신의 생성자 함수 이름을 적어서 자신의 생성자가 뭔지 알리기 때문이다. 지금 그 경우라서 b대신 a를 적은 것) 

(프로퍼티들의 색깔이 옅은 것도 있는데 그건 enumerable:false 인 것들이다. 열거 할 수 없는 건 innumerable이라고 저렇게 처리함.)

## <mark style="background: #FFF3A3A6;">ex) Array 내장 생성자 함수</mark>

```js
var arr = [1,2];
console.dir(Array);
console.dir(arr);
```
## <mark style="background: #BBFABBA6;">Array 함수 출력</mark>
![[Pasted image 20240405024253.png]]

Array의 정적 method(Array.method 형식으로 직접 접근해야하는 method들)인 from, isArray 등이 보이고 다양한 property들이 있는 것을 알 수 있다.

## <mark style="background: #BBFABBA6;">배열 arr 출력</mark>
![[Pasted image 20240405024136.png]]

1. 배열 arr라는 Array의 인스턴스는 Array(2)라는 생성자 함수에 의해서 생겨났다는 것을 알 수 있다. 
2. 아래에 0, 1 이 enumberable로 설정되어 찐한 글씨로 보인다.
3. 각각 먼저 할당했던 데이터인 1, 2 를 `0` `1` 이라는 프로퍼티가 갖고 있는 것을 확인 할 수 있다.

## <mark style="background: #BBFABBA6;">Array 참고 이미지</mark>

![[Pasted image 20240405025137.png]]

여기서 알 수 있는 것은 [1,2]에서 `from()`, `isArray()` 등을 직접 접근할 수 없지만 `push()`,`map()` 같은 것들에는 접근할 수 있었던 이유이다. ([1,2].from()이 작동하지 않은 이유)
## <mark style="background: #ABF7F7A6;">from(), isArray() 같은 것들을 인스턴스에서 접근할 수 없었던 이유</mark>

`from()`, `isArray()` 는 static method 로써 Array 안에 존재하는 method들이다.

## <mark style="background: #ABF7F7A6;">push(), map() 같은 것들은 인스턴스에서 접근할 수 있었던 이유</mark>

1. `push()`, `map()` 같은 method들은 prototype 객체에 있는 method이다.
2. [1,2]의 `__proto__`가 해당 prototype 객체를 참조한다.
3.  그로 인해서 [1,2].`__proto__`.methodName 으로 접근할 수 있다.
4.  여기서 `__proto__`가 생략 가능하다.
5. [1,2].methodName로 접근가능하며 여기서의 this는 호출한 객체인 [1,2]가 된다. 

```js
var arr = [1,2];
arr.forEach(function(){}); // 가능
Array.isArray(arr); // true
arr.isArray(); //TypeError: arr.isArray is not a function
```

## <mark style="background: #FFB86CA6;">constructor property</mark>

단어 그대로 원래의 생성자 함수를 참조하는 property, prototype 객체 내부에 존재하며 이를 통해 instance가 원본 생성자 함수가 무엇인지 확인할 수 있다.

```js
var arr = [1,2];
Array.prototype.constructor === Array //true
arr.__proto__.constructor === Array //true
arr.constructor === Array // true

var arr2 = new arr.constrctor(3,4);
console.log(arr2); // [3,4]
```

constructor는 읽기 전용 속성이 부여된 경우(기본형 리터럴 변수- String, Number,Boolean)를 제외하면 값을 바꿀 수 있다.

```js
var NewConstructor = function () {
  console.log("this is new constructor!");
};

var dataTypes = [
  1,
  "test",
  true,
  {},
  [],
  function () {},
  /test/,
  new Number(),
  new String(),
  new Boolean(),
  new Object(),
  new Array(),
  new Function(),
  new RegExp(),
  new Date(),
  new Error(),
];

dataTypes.forEach(function (d) {
  d.constructor = NewConstructor;
  console.log(d.constructor.name, "&", d instanceof NewConstructor);
});
```
![[Pasted image 20240405051703.png]]

이처럼 constructor는 생성자 함수가 무엇인지 확인하는 프로퍼티일 뿐 생성자 함

수가 무엇인지 조정하지는 못하며 이것이 확실히 생성자 함수 원본이라고 확신할 

수도 없다.

## <mark style="background: #FFF3A3A6;">constructor 접근법</mark>

```js
[Constructor]
[Constructor].prototype.constructor
[Instance].__proto__.constructor
[Instance].constructor
Object.getPrototypeOf([Instance]).constructor
```

위 코드는 모두 같은 constructor를 가리킨다.

```js
[Constructor].prototype
[Instance].__proto__
[Instance]
Object.getPrototypeOf([Instance])
```

위 코드는 모두 같은 객체를 가리킨다.

## <mark style="background: #BBFABBA6;">ex)</mark>
```js
var Person = function (name) {
  this.name = name;
};
var p1 = new Person ('사람1');
var p1Proto = Object.getPrototypeOf(p1);
var p2 = new Person.prototype.constructor('사람2');
var p3 = new p1Proto.constructor('사람3');
var p4 = new p1.__proto__.constructor('사람4');
var p5 = new p1.constructor('사람5');
  
[p1,p2,p3,p4,p5].forEach((p)=>{
  console.log(p,p instanceof Person);
})
```
```terminal
Person { name: '사람1' } true
Person { name: '사람2' } true
Person { name: '사람3' } true
Person { name: '사람4' } true
Person { name: '사람5' } true
```

## <mark style="background: #FF5582A6;">Prototype Chain</mark>

## <mark style="background: #FFB86CA6;">Method Override</mark>

method 위에 method를 얹는 것

```js
// 객체 생성
var Person = function (name){
  this.name= name;
};

// Person이라는 객체의 prototype에 getName이라는 method 설정
Person.prototype.getName = function(){
  return this.name;
}

// construct
var gj = new Person('giju');

// Method Override
gj.getName=function(){
  return '안녕 '+this.name;
}

console.log(gj.getName()); //안녕 giju
```

위의 코드를 보면 `gj.__proto__.getName`의 `return this.name`이 아닌 Override한 함수가 호출된 것을 확인할 수 있다.

JS엔진이 method를 찾는 방식은 우선 가까운 대상인 자신의 property를 찾고 없으면 `__proto__`에서 검색하는 순서로 반복되며 진행된다.

고로 위의 코드는 가장 가까운 `gj.getName`에 있는 함수가 호출된 것이다.

Override된 method말고 처음 method에 접근하고 싶으면 다음과 같이 하면 된다.

```js
console.log(gj.__proto__.getName()); //undefined (this 때문에)

// this까지 반영하려면
console.log(gj.__proto__.getName.call(gj)) // apply도 된다.
// return this.name
```

## <mark style="background: #FFB86CA6;">Prototype Chain Concepts</mark>

## <mark style="background: #FFF3A3A6;">Object 내부 구조</mark>
```js
console.dir({a:1});
```
![[Pasted image 20240405082012.png]]

{a:1} 은 `Object` 의 instance인 것을 첫줄에서 알 수 있고 그 안에 a, 그리고 `__proto__`으로 인해서 여러가지 내부 메서드 들을 확인할 수 있다.

## <mark style="background: #FFF3A3A6;">Array 내부 구조</mark>

```js
console.dir([1,2]);
```


![[Pasted image 20240405082720.png]]
---중략---
![[Pasted image 20240405082736.png]]
[1,2]는 Array(2)의 method 이고 `__proto__` 에는 배열 메서드 들, constructor가 들어가 있다.

이때, `__proto__`안의 `__proto__`가 Object인 것을 알 수 있는 데 이것은 `__proto__`(`[[Prototype]]`)도 결국엔 객체이기 때문이다.

모든 객체의 `__proto__`는 Object.prototype과 연결되는데 이건 prototype 객체도 예외가 아니다.
![[Pasted image 20240405083313.png]]

그림으로 나타내면 위와 같다. `__proto__`는 생략이 가능하기 때문에 Array.prototype 내부의 method를 실행할 수 있었다. 

그것과 같이 Array.prototype에서의 `__proto__`도 생략 가능하기 때문에 Object.prototype 내부의 method 역시 실행할 수 있다.

```js
var arr = [1,2];
arr/*.__proto__*/.push(3); // Array.prototype에 있는 method
arr/*.__proto__.__proto__*/.hasOwnProperty(2); // true // Object.prototype에 있는 method
```

위와 같이 `__proto__` 가 연쇄적으로 이어지는 것은 **Prototype Chain** 이라고 하고 

이것을 이용해서 검색해 나가는 것을 **Prototype Chaining** 이라고 한다.
(JS엔진에서 Method를 탐색할 때 자신을 탐색해본 후 `__proto__`을 살펴보고 다시 들어가서 `__proto__`를 또 살펴보는 방식)

## <mark style="background: #FFF3A3A6;">ex) arr의 Prototype Chaining</mark>
```js
var arr = [1, 2];
Array.prototype.toString.call(arr); // 1,2
Object.prototype.toString.call(arr); // [object Array]
arr.toString(); // 1,2

arr.toString = function () {console.log(this); return this.join("_");};
// 화살표 함수 쓰면 this가 window가 되서 TypeError *주의*

arr.toString(); // 1_2
```

Object.prototype.toString도 있고 Array.prototype.toString도 따로 있다.
(Object.prototype.toString은 \[Object type] 형식으로 Type을 출력해주는 method라고 생각하면 된다.)

Prototype Chaining에 의해서 arr.toString은 내가 지정한 커스텀 함수로 호출되는 것을 확인할 수 있다.

## <mark style="background: #FFF3A3A6;">데이터 타입별 Prototype Chain</mark>

![[Pasted image 20240405092655.png]]

사실상 null을 제외한 모든 데이터 타입이 prototype을 갖고 있기 때문에 이론적으로 Object prototype안의 method들을 사용할 수 있다.

## <mark style="background: #FFF3A3A6;">전체 프로토타입 구조</mark>

![[Prototype_240405_094707.jpg]]
간단하게 되어있었던 도식을 풀어보았다.

1. function 생성자 함수도 function 생성자 함수를 가르킨다.(재귀, 무한)
	1. 무한이진 않다. 사용자가 찾을 때 불러올 뿐이다.
	2. 메모리 상에서는 결국 같은 생성자 함수를 가르키기 때문에 메모리가 낭비되지 않는다.
2. function의 prototype도  객체이므로 Object를 가르킨다.

## <mark style="background: #FFF3A3A6;">Object 전용 Method의 예외 사항</mark>

객체 안에서만 사용할 메서드는 Object.prototype에서 정의하면 안된다.

```js
// getEntries : hasOwnProperty
Object.prototype.getEntries = function () {
  var res = [];
  for (var prop in this) {
    if (this.hasOwnProperty(prop)) {  // key 값이 상속된게 아니라 자신의 key값일 경우
      res.push([prop, this[prop]]);
    }
  }
  return res;
};


var data = [
  ["object", { a: 1, b: 2, c: 3 }],
  ["number", 345],
  ["string", "abc"],
  ["boolean", false],
  ["func", function () {}],
  ["array", [1, 2, 3]],
];

// 각 배열의 인덱스 1을 순회
data.forEach(function (datum) {
  console.log(datum[1].getEntries());
});
```
```terminal
[ [ 'a', 1 ], [ 'b', 2 ], [ 'c', 3 ] ]
[]
[ [ '0', 'a' ], [ '1', 'b' ], [ '2', 'c' ] ]
[]
[]
[ [ '0', 1 ], [ '1', 2 ], [ '2', 3 ] ]
```

객체의 prototype객체는 기본형, 참조형 데이터가 prototype chaining을 이용해서 도달할 수 있게 되기 때문에 

객체 안에서만 사용하는 method를 만들기 위해서 어쩔 수 없이 static한 방식으로, this를 활용하기 위해 인자로 this를 

받는 방식으로 변화할 수 밖에 없었고 실제로 그렇게 만들어져 있다.

`Object.freeze(instance), Object.getPrototypeOf(instance)` 등등

따라서 Object.prototype에는 어떤 데이터에서도 사용할 수 있는 범용적인 method들만 있다.

## <mark style="background: #FFF3A3A6;">Object.create(Object)</mark>

create라는 Object의 static method는 인자(Object)를 `__proto__` 로 갖는 객체를 생성합니다. (null로 할 경우 `__proto__` 가 없는 객체 생성)

```js
var _proto= Object.create(null);
_proto.getValue = function (key){
	return this[key];
};
var obj = Object.create(_proto);
obj.a = 1;
console.log(obj.getValue('a'));
console.dir(obj);
```
![[Pasted image 20240405112616.png]]

## <mark style="background: #FFB86CA6;">Multi Prototype Chain</mark>

일반적으로 JS의 기본 내장 데이터 타입들은 모두 Prototype Chain이 1단계이거나 2단계로 끝나는 경우만 있었지만 사용자가 새롭게 만드는 경우에는 그 이상도 얼마든지 가능하다.

## <mark style="background: #FFF3A3A6;">Prototype Chain을 수정해서 다른 생성자 함수의 method, property 사용하기</mark>

`__proto__`가 참조하고 있는 생성자의 prototype이 다른 상위 생성자 함수의 instance를 참조하고 있으면 된다.

## <mark style="background: #BBFABBA6;">Prototype Chain 활용</mark>

```js
var Grade = function(){
  var args = Array.prototype.slice.call(arguments); // 유사 배열인 arguments를 그냥 배열로 변환
  console.log(args);
  for(var i = 0; i<args.length ;i++){
    this[i]=args[i]; // this라는 객체에 배열의 인덱스를 하나씩 넣음
  }
  console.log(this,args); 
  // 결과적으로 
  // this: Object, args: Array
  // 를 각각 [[Proto]]로 가진 객체 둘이 됨.
  this.length = args.length;
};
var g = new Grade(100,80);
// this가 그대로 g로 들어가서 유사배열 생성
```
![[Pasted image 20240405221224.png]]

여기서 g는 유사배열이라 Array Method를 사용할 수 없는데 Array Method를 사용하게 하려면 Prototype Chain을 활용해야 한다.

```js
Grade.prototype = [];
// 위 코드부터 시작해야됨.
```

이 짧은 코드로 일어난 일은 다음과 같다.

![[Pasted image 20240405222453.png]]
![[Pasted image 20240405222504.png]]

이로써 g {0:100, 1:80, length:2 }에서 `splice, slice, map` 같은 Array의 method들을 prototype Chain으로 인해서 사용할 수 있게 되었다.

정의를 여기에 대입해보면 다음과 같다.

>`__proto__`가 참조하고 있는 생성자(Grade)의 prototype이 다른 상위 생성자 함수(Array)의 instance(`[]`)를 참조하고 있으면 된다. (참조하고 있는 생성자 위에 내가 넣고 싶은 prototype Chain 만들어 버리기)


이론상 무한의 단계를 생성할 수 있다.